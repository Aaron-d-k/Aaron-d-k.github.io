#version 300 es
precision highp float;

// Input vertex attributes (from vertex shader)
in vec3 fragPosition;
in vec2 fragTexCoord;

out vec4 fragColor;

uniform mat4 params;
uniform vec3 zp;

mat3x2 calcQ()
{
    return transpose(mat2x3(params[0].xyz, vec3(params[1].zw,params[2].x)));
}

mat2 calcM()
{
    return mat2(params[0].w,params[2].y,params[1].x,params[2].z);
}

float getsmoothiter_div(vec2 p, int i)
{
    float currdistconst = log(length(p));
    vec2 d = normalize(p);
    mat3x2 Q = calcQ();
    for (int j = 1; j < 10; j++)
    {
        d = Q*vec3(d.x*d.x, d.x*d.y, d.y*d.y);
        currdistconst += pow(2.0,float(-j))*log(length(d));
        d = normalize(d);
    }
    return log2(currdistconst) - float(i);
}

mat2 jacobian(vec2 p)
{
    return mat2(
        dot(vec3(2.0*p.x, p.y, 1.0), params[0].xyw),
        dot(vec3(2.0*p.x, p.y, 1.0), vec3(params[1].zw,params[2].y)),

        dot(vec3(p.x, 2.0*p.y, 1.0), vec3(params[0].yz,params[1].x)),
        dot(vec3(p.x, 2.0*p.y, 1.0), vec3(params[1].w,params[2].xz))
    );
}

//only works well with equal magnitude eigenvalues (in our case, this usually means complex number)
float getapproxlogdist0_conv(vec2 p, int i)
{
    mat2 Minv = inverse(calcM());
    vec2 unravel = p;

    float outp = 0.0;

    for (int j = 0; j < i; j++)
    {
        outp += log(length(unravel));
        unravel = normalize(unravel);
        unravel = Minv*unravel;
    }

    return outp + log(length(unravel));
}

//only works well with unequal magnitude real eigenvalues.
float getsmoothiter_conv(vec2 p, int i)
{   
    return log(length(p))/log(params[3].z) - float(i);
}

//only works well with unequal magnitude real eigenvalues.
float getapproxlogdistboundary_conv(vec2 p, mat2 netjacobian, int i)
{
    return log(length(p)) - log(length(netjacobian*normalize(p)));
}


float tomix(float num)
{
    return 0.5-0.5*sin(2.0*num);
}


void main()
{
    vec4 finalColor = vec4(0.5, 0.3, 0.1, 1.0);

    const vec4 green = vec4(0.008, 0.349, 0.059, 1.0);
    const vec4 yellow = vec4(0.91, 0.9, 0.059, 1.0);

    const vec4 cgreen = vec4(0.08, 0.51, 0.05, 1.0);
    const vec4 cyellow = vec4(0.86, 0.80, 0.09, 1.0);


    vec2 p = fragTexCoord;

    
    mat2 netjacobian = mat2(1.0,0.0,0.0,1.0);
    mat2 M = calcM();
    mat3x2 Q = calcQ();
    vec2 C = vec2(params[1].y,params[2].w);

    for (int i = 0; i < 1000; i++)
    {
        if (dot(p,p) < params[3].x*1e-3)
        {
            //float d = getapproxlogdist0_conv(p, i);
            float d = getapproxlogdistboundary_conv(p, netjacobian, i);
            finalColor = mix(cyellow, cgreen, tomix(d));
            //if (it<log(0.001/zp.x)) finalColor = vec4(1.0);
            break;
        }
        if (dot(p,p) > 1e8)
        {
            float it =  getsmoothiter_div(p, i);
            finalColor = mix(yellow, green, tomix(it));
            break;
        }

        netjacobian *= jacobian(p);

        p = C + M*p + Q*vec3(p.x*p.x, p.x*p.y, p.y*p.y); //loool i just forgot the constant
        /*vec2(
            dot(vec4(p.x*p.x, p.x*p.y, p.y*p.y, p.x), params[0]) + dot(vec2(p.y, 1.0), params[1].xy),
            dot(vec2(p.x*p.x, p.y*p.x), params[1].zw) + dot(vec4(p.y*p.y, p.x, p.y, 1.0), params[2])
        );*/
    }    

    if (determinant(netjacobian)/dot(p,p) > pow(2.0,25.0))
    {
    //    finalColor.z=1.0;
    }

    // Gamma correction
    finalColor = pow(finalColor, vec4(1.0/2.2));

    finalColor.w=1.0;

    fragColor = finalColor;
}#version 300 es

precision highp float;
in vec3 vertexPosition;
in vec2 vertexTexCoord; 
in vec4 vertexColor; 
out vec2 fragTexCoord;


uniform vec3 zp;

uniform mat4 mvp; 

void main() 
{   
    gl_Position = mvp*vec4(vertexPosition, 1.0);
    fragTexCoord = zp.yz + gl_Position.xy*vec2(1.0,-1.0)/zp.x ;
}#version 300 es
precision highp float;

// Input vertex attributes (from vertex shader)
in vec3 fragPosition;
in vec2 fragTexCoord;

out vec4 fragColor;

uniform mat4 params;
uniform vec3 zp;

mat3x2 calcQ()
{
    return transpose(mat2x3(params[0].xyz, vec3(params[1].zw,params[2].x)));
}

mat2 calcM()
{
    return mat2(params[0].w,params[2].y,params[1].x,params[2].z);
}

mat2 jacobian(vec2 p)
{
    return mat2(
        dot(vec3(2.0*p.x, p.y, 1.0), params[0].xyw),
        dot(vec3(2.0*p.x, p.y, 1.0), vec3(params[1].zw,params[2].y)),

        dot(vec3(p.x, 2.0*p.y, 1.0), vec3(params[0].yz,params[1].x)),
        dot(vec3(p.x, 2.0*p.y, 1.0), vec3(params[1].w,params[2].xz))
    );
}

// All components are in the range [0â€¦1], including hue.
vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}


void main()
{
    vec4 finalColor = vec4(0.5, 0.3, 0.1, 1.0);

    const vec4 green = vec4(0.008, 0.349, 0.059, 1.0);
    const vec4 yellow = vec4(0.91, 0.9, 0.059, 1.0);

    const vec4 red = vec4(0.82, 0.02, 0.18, 1.0);
    const vec4 blue = vec4(0.49, 0.90, 0.99, 1.0);


    vec2 p = fragTexCoord;

    
    mat2 M = calcM();
    mat3x2 Q = calcQ();
    vec2 C = vec2(params[1].y,params[2].w);

    float dat_l = log(length(C + M*p + Q*vec3(p.x*p.x, p.x*p.y, p.y*p.y) - p));
    vec2 dat_c = C + M*p + Q*vec3(p.x*p.x, p.x*p.y, p.y*p.y) - p;
    finalColor.xyz = hsv2rgb(vec3(0.5+atan(dat_c.y,dat_c.x)/radians(360.),1.0,0.5+(atan(dat_l)/radians(180.))));//mix(blue,red,0.5+(atan(dat)/radians(180.)));

    // Gamma correction
    finalColor = pow(finalColor, vec4(1.0/2.2));

    finalColor.w=1.0;

    fragColor = finalColor;
}